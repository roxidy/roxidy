import { invoke } from "@tauri-apps/api/core";

// ============================================================================
// Types
// ============================================================================

export interface SidecarStatus {
  active_session: boolean;
  session_id: string | null;
  event_count: number;
  buffer_size: number;
  embeddings_ready: boolean;
  llm_ready: boolean;
  storage_ready: boolean;
  workspace_path: string | null;
}

export interface SidecarSession {
  id: string;
  workspace_path: string;
  initial_request: string;
  started_at: string;
  ended_at: string | null;
  event_count: number;
  checkpoint_count: number;
  files_touched: string[];
}

export interface SessionEvent {
  id: string;
  session_id: string;
  timestamp: string;
  event_type: EventType;
  content: string;
  files: string[];
}

export type EventType =
  | { type: "user_prompt"; intent: string }
  | { type: "file_edit"; path: string; operation: FileOperation; summary?: string }
  | {
      type: "tool_call";
      tool_name: string;
      args_summary: string;
      reasoning?: string;
      success: boolean;
    }
  | { type: "agent_reasoning"; content: string; decision_type?: DecisionType }
  | { type: "user_feedback"; feedback_type: FeedbackType; target_tool?: string; comment?: string }
  | { type: "error_recovery"; error_message: string; recovery_action?: string; resolved: boolean }
  | { type: "commit_boundary"; suggested_message?: string; files_in_scope: string[] }
  | { type: "session_start"; initial_request: string }
  | { type: "session_end"; summary?: string }
  | { type: "ai_response"; content: string; truncated: boolean; duration_ms?: number };

export type FileOperation = "create" | "modify" | "delete" | { rename: { from: string } };

export type DecisionType = "approach_choice" | "tradeoff" | "fallback" | "assumption";

export type FeedbackType = "approve" | "deny" | "modify" | "annotate";

export interface Checkpoint {
  id: string;
  session_id: string;
  timestamp: string;
  summary: string;
  event_ids: string[];
  files_touched: string[];
}

export interface CommitDraft {
  message: string;
  scope: string;
  files: string[];
  reasoning: string;
  /** System prompt used for generation (if LLM was used) */
  system_prompt?: string;
  /** User prompt used for generation (if LLM was used) */
  user_prompt?: string;
  /** Whether this was generated by LLM (true) or template (false) */
  llm_generated: boolean;
  /** Number of events used to generate this draft */
  event_count: number;
  /** Number of checkpoints used */
  checkpoint_count: number;
}

export interface SessionSummary {
  session_id: string;
  title: string;
  description: string;
  key_actions: string[];
  files_modified: string[];
  decisions_made: string[];
}

export interface HistoryResponse {
  answer: string;
  relevant_events: SessionEvent[];
  confidence: number;
}

export interface StorageStats {
  event_count: number;
  checkpoint_count: number;
  session_count: number;
  total_size_bytes: number;
  oldest_event: string | null;
  newest_event: string | null;
}

export interface ModelsStatus {
  embedding_available: boolean;
  embedding_size_bytes: number;
  llm_available: boolean;
  llm_size_bytes: number;
}

export interface IndexStatus {
  events_indexed: boolean;
  checkpoints_indexed: boolean;
  events_count: number;
  checkpoints_count: number;
}

// ============================================================================
// Synthesis Backend Types
// ============================================================================

/** LLM provider configuration for remote backends */
export type LlmProvider =
  | {
      type: "VertexAnthropic";
      project_id: string;
      location: string;
      model?: string;
      credentials_path?: string;
    }
  | {
      type: "OpenAI";
      model?: string;
      api_key?: string;
      base_url?: string;
    }
  | {
      type: "Grok";
      model?: string;
      api_key?: string;
    }
  | {
      type: "OpenAICompatible";
      model: string;
      base_url: string;
      api_key?: string;
    };

/** Synthesis backend configuration */
export type SynthesisBackend =
  | { backend: "Local" }
  | { backend: "Remote"; provider: LlmProvider }
  | { backend: "Template" };

/** Available backend option for UI */
export type BackendOption =
  | "local"
  | "vertex-anthropic"
  | "openai"
  | "grok"
  | "openai-compatible"
  | "template";

// ============================================================================
// Layer 1 Session State Types
// ============================================================================

/** Goal source types */
export type GoalSource = "initial_prompt" | "user_clarification" | "inferred";

/** Goal priority levels */
export type GoalPriority = "high" | "medium" | "low";

/** Progress note for a goal */
export interface ProgressNote {
  timestamp: string;
  note: string;
}

/** Goal in the goal stack */
export interface Goal {
  id: string;
  description: string;
  source: GoalSource;
  created_at: string;
  completed: boolean;
  completed_at?: string;
  sub_goals: Goal[];
  priority: GoalPriority;
  blocked_by?: string;
  progress_notes: ProgressNote[];
}

/** Decision category types */
export type DecisionCategory = "architecture" | "library" | "approach" | "tradeoff" | "fallback";

/** Decision confidence levels */
export type DecisionConfidence = "high" | "medium" | "low" | "uncertain";

/** Alternative option that was rejected */
export interface Alternative {
  description: string;
  rejection_reason: string;
}

/** Decision made during a session */
export interface Decision {
  id: string;
  timestamp: string;
  choice: string;
  rationale: string;
  alternatives_rejected: string[];
  triggering_event_id: string;
  alternatives: Alternative[];
  category: DecisionCategory;
  confidence: DecisionConfidence;
  reversible: boolean;
  related_files: string[];
}

/** File understanding levels */
export type UnderstandingLevel = "full" | "partial" | "surface";

/** File change history entry */
export interface FileChange {
  timestamp: string;
  summary: string;
  diff_preview?: string;
}

/** Context about a file */
export interface FileContext {
  path: string;
  summary: string;
  last_read_at?: string;
  last_modified_at?: string;
  relevance: string;
  understanding_level: UnderstandingLevel;
  key_exports: string[];
  dependencies: string[];
  change_history: FileChange[];
  notes: string[];
}

/** Error entry */
export interface ErrorEntry {
  id: string;
  timestamp: string;
  error: string;
  context: string;
  resolution?: string;
  resolved: boolean;
  resolved_at?: string;
}

/** Open question source types */
export type QuestionSource = "from_reasoning" | "from_user" | "inferred_from_error";

/** Open question priority levels */
export type QuestionPriority = "blocking" | "important" | "informational";

/** Open question */
export interface OpenQuestion {
  id: string;
  question: string;
  created_at: string;
  source: QuestionSource;
  context: string;
  priority: QuestionPriority;
  answered_at?: string;
  answer?: string;
}

/** Complete session state */
export interface SessionState {
  session_id: string;
  updated_at: string;
  goal_stack: Goal[];
  narrative: string;
  narrative_updated_at: string;
  decisions: Decision[];
  file_contexts: Record<string, FileContext>;
  errors: ErrorEntry[];
  open_questions: OpenQuestion[];
}

// ============================================================================
// API Functions
// ============================================================================

/** Get the current sidecar status */
export async function getSidecarStatus(): Promise<SidecarStatus> {
  return invoke<SidecarStatus>("sidecar_status");
}

/** Initialize the sidecar for a workspace */
export async function initializeSidecar(workspacePath: string): Promise<void> {
  return invoke("sidecar_initialize", { workspacePath });
}

/** Start a new capture session */
export async function startSession(initialRequest: string): Promise<string> {
  return invoke<string>("sidecar_start_session", { initialRequest });
}

/** End the current session */
export async function endSession(): Promise<SidecarSession | null> {
  return invoke<SidecarSession | null>("sidecar_end_session");
}

/** Get the current session ID */
export async function getCurrentSession(): Promise<string | null> {
  return invoke<string | null>("sidecar_current_session");
}

/** Generate a commit message for a session */
export async function generateCommit(sessionId?: string): Promise<CommitDraft> {
  return invoke<CommitDraft>("sidecar_generate_commit", { sessionId });
}

/** Generate a summary for a session */
export async function generateSummary(sessionId?: string): Promise<SessionSummary> {
  return invoke<SessionSummary>("sidecar_generate_summary", { sessionId });
}

/** Query session history with a question */
export async function queryHistory(question: string, limit?: number): Promise<HistoryResponse> {
  return invoke<HistoryResponse>("sidecar_query_history", { question, limit });
}

/** Search events by keyword */
export async function searchEvents(query: string, limit?: number): Promise<SessionEvent[]> {
  return invoke<SessionEvent[]>("sidecar_search_events", { query, limit });
}

/** Get events for a specific session */
export async function getSessionEvents(sessionId: string): Promise<SessionEvent[]> {
  return invoke<SessionEvent[]>("sidecar_get_session_events", { sessionId });
}

/** Get checkpoints for a specific session */
export async function getSessionCheckpoints(sessionId: string): Promise<Checkpoint[]> {
  return invoke<Checkpoint[]>("sidecar_get_session_checkpoints", { sessionId });
}

/** List all sessions */
export async function listSessions(): Promise<SidecarSession[]> {
  return invoke<SidecarSession[]>("sidecar_list_sessions");
}

/** Get storage statistics */
export async function getStorageStats(): Promise<StorageStats> {
  return invoke<StorageStats>("sidecar_storage_stats");
}

/** Get model status */
export async function getModelsStatus(): Promise<ModelsStatus> {
  return invoke<ModelsStatus>("sidecar_models_status");
}

/** Download models */
export async function downloadModels(): Promise<void> {
  return invoke("sidecar_download_models");
}

/** Export a session to JSON */
export async function exportSession(sessionId: string): Promise<string> {
  return invoke<string>("sidecar_export_session", { sessionId });
}

/** Export a session to a file */
export async function exportSessionToFile(sessionId: string, outputPath: string): Promise<void> {
  return invoke("sidecar_export_session_to_file", { sessionId, outputPath });
}

/** Import a session from JSON */
export async function importSession(json: string): Promise<string> {
  return invoke<string>("sidecar_import_session", { json });
}

/** Get pending files for commit boundary */
export async function getPendingFiles(): Promise<string[]> {
  return invoke<string[]>("sidecar_pending_files");
}

/** Clear commit boundary tracking */
export async function clearCommitBoundary(): Promise<void> {
  return invoke("sidecar_clear_commit_boundary");
}

/** Clean up old events */
export async function cleanup(maxAgeDays?: number): Promise<number> {
  return invoke<number>("sidecar_cleanup", { maxAgeDays });
}

/** Get index status */
export async function getIndexStatus(): Promise<IndexStatus> {
  return invoke<IndexStatus>("sidecar_index_status");
}

/** Create vector indexes */
export async function createIndexes(): Promise<IndexStatus> {
  return invoke<IndexStatus>("sidecar_create_indexes");
}

/** Set the synthesis backend */
export async function setBackend(backend: SynthesisBackend): Promise<string> {
  return invoke<string>("sidecar_set_backend", { backend });
}

/** Get available backend options */
export async function getAvailableBackends(): Promise<BackendOption[]> {
  return invoke<BackendOption[]>("sidecar_available_backends");
}

// ============================================================================
// Layer 1 API Functions
// ============================================================================

/** Get the complete session state */
export async function getSessionState(sessionId?: string): Promise<SessionState | null> {
  return invoke<SessionState | null>("sidecar_get_session_state", { session_id: sessionId });
}

/** Get injectable context string for LLM prompts */
export async function getInjectableContext(sessionId?: string): Promise<string> {
  return invoke<string>("sidecar_get_injectable_context", { session_id: sessionId });
}

/** Get all goals for a session */
export async function getGoals(sessionId?: string): Promise<Goal[]> {
  return invoke<Goal[]>("sidecar_get_goals", { session_id: sessionId });
}

/** Get all file contexts for a session */
export async function getFileContexts(sessionId?: string): Promise<Record<string, FileContext>> {
  return invoke<Record<string, FileContext>>("sidecar_get_file_contexts", {
    session_id: sessionId,
  });
}

/** Get all decisions for a session */
export async function getDecisions(sessionId?: string): Promise<Decision[]> {
  return invoke<Decision[]>("sidecar_get_decisions", { session_id: sessionId });
}

/** Get all errors for a session */
export async function getErrors(sessionId?: string): Promise<ErrorEntry[]> {
  return invoke<ErrorEntry[]>("sidecar_get_errors", { session_id: sessionId });
}

/** Get all open questions for a session */
export async function getOpenQuestions(sessionId?: string): Promise<OpenQuestion[]> {
  return invoke<OpenQuestion[]>("sidecar_get_open_questions", { session_id: sessionId });
}

/** Answer an open question */
export async function answerQuestion(questionId: string, answer: string): Promise<void> {
  return invoke<void>("sidecar_answer_question", { question_id: questionId, answer });
}

/** Mark a goal as completed */
export async function completeGoal(goalId: string): Promise<void> {
  return invoke<void>("sidecar_complete_goal", { goal_id: goalId });
}

// ============================================================================
// Layer 1 Event Types
// ============================================================================

/** Layer 1 event type discriminators */
export type Layer1EventType =
  | "state_updated"
  | "goal_added"
  | "goal_completed"
  | "narrative_updated"
  | "decision_recorded"
  | "error_updated"
  | "question_added"
  | "question_answered"
  | "file_context_updated";

/** Session state was updated */
export interface Layer1EventStateUpdated {
  type: "state_updated";
  session_id: string;
  changes: string[];
}

/** A goal was added */
export interface Layer1EventGoalAdded {
  type: "goal_added";
  session_id: string;
  goal: Goal;
}

/** A goal was completed */
export interface Layer1EventGoalCompleted {
  type: "goal_completed";
  session_id: string;
  goal_id: string;
}

/** Narrative was updated */
export interface Layer1EventNarrativeUpdated {
  type: "narrative_updated";
  session_id: string;
  narrative: string;
}

/** A decision was recorded */
export interface Layer1EventDecisionRecorded {
  type: "decision_recorded";
  session_id: string;
  decision: Decision;
}

/** An error was added or resolved */
export interface Layer1EventErrorUpdated {
  type: "error_updated";
  session_id: string;
  error: ErrorEntry;
}

/** An open question was added */
export interface Layer1EventQuestionAdded {
  type: "question_added";
  session_id: string;
  question: OpenQuestion;
}

/** A question was answered */
export interface Layer1EventQuestionAnswered {
  type: "question_answered";
  session_id: string;
  question_id: string;
  answer: string;
}

/** File context was updated */
export interface Layer1EventFileContextUpdated {
  type: "file_context_updated";
  session_id: string;
  path: string;
  context: FileContext;
}

/** Union type for all Layer 1 events */
export type Layer1Event =
  | Layer1EventStateUpdated
  | Layer1EventGoalAdded
  | Layer1EventGoalCompleted
  | Layer1EventNarrativeUpdated
  | Layer1EventDecisionRecorded
  | Layer1EventErrorUpdated
  | Layer1EventQuestionAdded
  | Layer1EventQuestionAnswered
  | Layer1EventFileContextUpdated;
